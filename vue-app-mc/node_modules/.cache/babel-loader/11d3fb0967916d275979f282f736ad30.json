{"remainingRequest":"/Users/molly_s4/Desktop/code/Thesis_folders/Thesis-2022/vue-app-mc/node_modules/thread-loader/dist/cjs.js!/Users/molly_s4/Desktop/code/Thesis_folders/Thesis-2022/vue-app-mc/node_modules/babel-loader/lib/index.js!/Users/molly_s4/Desktop/code/Thesis_folders/Thesis-2022/vue-app-mc/node_modules/eslint-loader/index.js??ref--14-0!/Users/molly_s4/Desktop/code/Thesis_folders/Thesis-2022/vue-app-mc/src/jenks.js","dependencies":[{"path":"/Users/molly_s4/Desktop/code/Thesis_folders/Thesis-2022/vue-app-mc/src/jenks.js","mtime":1663635091798},{"path":"/Users/molly_s4/Desktop/code/Thesis_folders/Thesis-2022/vue-app-mc/babel.config.js","mtime":1663635091719},{"path":"/Users/molly_s4/Desktop/code/Thesis_folders/Thesis-2022/vue-app-mc/node_modules/cache-loader/dist/cjs.js","mtime":1658193979907},{"path":"/Users/molly_s4/Desktop/code/Thesis_folders/Thesis-2022/vue-app-mc/node_modules/thread-loader/dist/cjs.js","mtime":1658193979862},{"path":"/Users/molly_s4/Desktop/code/Thesis_folders/Thesis-2022/vue-app-mc/node_modules/babel-loader/lib/index.js","mtime":1658193980303},{"path":"/Users/molly_s4/Desktop/code/Thesis_folders/Thesis-2022/vue-app-mc/node_modules/eslint-loader/index.js","mtime":1658193979974}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc29ydC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qcyI7CgovLyAjIFtKZW5rcyBuYXR1cmFsIGJyZWFrcyBvcHRpbWl6YXRpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSmVua3NfbmF0dXJhbF9icmVha3Nfb3B0aW1pemF0aW9uKQovLwovLyBJbXBsZW1lbnRhdGlvbnM6IFsxXShodHRwOi8vZGFuaWVsamxld2lzLm9yZy9maWxlcy8yMDEwLzA2L0plbmtzLnBkZikgKHB5dGhvbiksCi8vIFsyXShodHRwczovL2dpdGh1Yi5jb20vdnZvb3Z2L2RqZW8tamVua3MvYmxvYi9tYXN0ZXIvbWFpbi5qcykgKGJ1Z2d5KSwKLy8gWzNdKGh0dHBzOi8vZ2l0aHViLmNvbS9zaW1vZ2VvL2dlb3N0YXRzL2Jsb2IvbWFzdGVyL2xpYi9nZW9zdGF0cy5qcyNMNDA3KSAod29ya3MpCnZhciBqZW5rcyA9IGZ1bmN0aW9uIGplbmtzKGRhdGEsIG5fY2xhc3NlcykgewogIC8vIENvbXB1dGUgdGhlIG1hdHJpY2VzIHJlcXVpcmVkIGZvciBKZW5rcyBicmVha3MuIFRoZXNlIG1hdHJpY2VzCiAgLy8gY2FuIGJlIHVzZWQgZm9yIGFueSBjbGFzc2luZyBvZiBkYXRhIHdpdGggYGNsYXNzZXMgPD0gbl9jbGFzc2VzYAogIGZ1bmN0aW9uIGdldE1hdHJpY2VzKGRhdGEsIG5fY2xhc3NlcykgewogICAgLy8gaW4gdGhlIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uLCB0aGVzZSBtYXRyaWNlcyBhcmUgcmVmZXJyZWQgdG8KICAgIC8vIGFzIGBMQ2AgYW5kIGBPUGAKICAgIC8vCiAgICAvLyAqIGxvd2VyX2NsYXNzX2xpbWl0cyAoTEMpOiBvcHRpbWFsIGxvd2VyIGNsYXNzIGxpbWl0cwogICAgLy8gKiB2YXJpYW5jZV9jb21iaW5hdGlvbnMgKE9QKTogb3B0aW1hbCB2YXJpYW5jZSBjb21iaW5hdGlvbnMgZm9yIGFsbCBjbGFzc2VzCiAgICB2YXIgbG93ZXJfY2xhc3NfbGltaXRzID0gW10sCiAgICAgICAgdmFyaWFuY2VfY29tYmluYXRpb25zID0gW10sCiAgICAgICAgLy8gbG9vcCBjb3VudGVycwogICAgaSwKICAgICAgICBqLAogICAgICAgIC8vIHRoZSB2YXJpYW5jZSwgYXMgY29tcHV0ZWQgYXQgZWFjaCBzdGVwIGluIHRoZSBjYWxjdWxhdGlvbgogICAgdmFyaWFuY2UgPSAwOyAvLyBJbml0aWFsaXplIGFuZCBmaWxsIGVhY2ggbWF0cml4IHdpdGggemVyb2VzCgogICAgZm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoICsgMTsgaSsrKSB7CiAgICAgIHZhciB0bXAxID0gW10sCiAgICAgICAgICB0bXAyID0gW107CgogICAgICBmb3IgKGogPSAwOyBqIDwgbl9jbGFzc2VzICsgMTsgaisrKSB7CiAgICAgICAgdG1wMS5wdXNoKDApOwogICAgICAgIHRtcDIucHVzaCgwKTsKICAgICAgfQoKICAgICAgbG93ZXJfY2xhc3NfbGltaXRzLnB1c2godG1wMSk7CiAgICAgIHZhcmlhbmNlX2NvbWJpbmF0aW9ucy5wdXNoKHRtcDIpOwogICAgfQoKICAgIGZvciAoaSA9IDE7IGkgPCBuX2NsYXNzZXMgKyAxOyBpKyspIHsKICAgICAgbG93ZXJfY2xhc3NfbGltaXRzWzFdW2ldID0gMTsKICAgICAgdmFyaWFuY2VfY29tYmluYXRpb25zWzFdW2ldID0gMDsgLy8gaW4gdGhlIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uLCA5OTk5OTk5IGlzIHVzZWQgYnV0CiAgICAgIC8vIHNpbmNlIEphdmFzY3JpcHQgaGFzIGBJbmZpbml0eWAsIHdlIHVzZSB0aGF0LgoKICAgICAgZm9yIChqID0gMjsgaiA8IGRhdGEubGVuZ3RoICsgMTsgaisrKSB7CiAgICAgICAgdmFyaWFuY2VfY29tYmluYXRpb25zW2pdW2ldID0gSW5maW5pdHk7CiAgICAgIH0KICAgIH0KCiAgICBmb3IgKHZhciBsID0gMjsgbCA8IGRhdGEubGVuZ3RoICsgMTsgbCsrKSB7CiAgICAgIC8vIGBTWmAgb3JpZ2luYWxseS4gdGhpcyBpcyB0aGUgc3VtIG9mIHRoZSB2YWx1ZXMgc2VlbiB0aHVzCiAgICAgIC8vIGZhciB3aGVuIGNhbGN1bGF0aW5nIHZhcmlhbmNlLgogICAgICB2YXIgc3VtID0gMCwKICAgICAgICAgIC8vIGBaU1FgIG9yaWdpbmFsbHkuIHRoZSBzdW0gb2Ygc3F1YXJlcyBvZiB2YWx1ZXMgc2VlbgogICAgICAvLyB0aHVzIGZhcgogICAgICBzdW1fc3F1YXJlcyA9IDAsCiAgICAgICAgICAvLyBgV1RgIG9yaWdpbmFsbHkuIFRoaXMgaXMgdGhlIG51bWJlciBvZgogICAgICB3ID0gMCwKICAgICAgICAgIC8vIGBJVmAgb3JpZ2luYWxseQogICAgICBpNCA9IDA7IC8vIGluIHNldmVyYWwgaW5zdGFuY2VzLCB5b3UgY291bGQgc2F5IGBNYXRoLnBvdyh4LCAyKWAKICAgICAgLy8gaW5zdGVhZCBvZiBgeCAqIHhgLCBidXQgdGhpcyBpcyBzbG93ZXIgaW4gc29tZSBicm93c2VycwogICAgICAvLyBpbnRyb2R1Y2VzIGFuIHVubmVjZXNzYXJ5IGNvbmNlcHQuCgogICAgICBmb3IgKHZhciBtID0gMTsgbSA8IGwgKyAxOyBtKyspIHsKICAgICAgICAvLyBgSUlJYCBvcmlnaW5hbGx5CiAgICAgICAgdmFyIGxvd2VyX2NsYXNzX2xpbWl0ID0gbCAtIG0gKyAxLAogICAgICAgICAgICB2YWwgPSBkYXRhW2xvd2VyX2NsYXNzX2xpbWl0IC0gMV07IC8vIGhlcmUgd2UncmUgZXN0aW1hdGluZyB2YXJpYW5jZSBmb3IgZWFjaCBwb3RlbnRpYWwgY2xhc3NpbmcKICAgICAgICAvLyBvZiB0aGUgZGF0YSwgZm9yIGVhY2ggcG90ZW50aWFsIG51bWJlciBvZiBjbGFzc2VzLiBgd2AKICAgICAgICAvLyBpcyB0aGUgbnVtYmVyIG9mIGRhdGEgcG9pbnRzIGNvbnNpZGVyZWQgc28gZmFyLgoKICAgICAgICB3Kys7IC8vIGluY3JlYXNlIHRoZSBjdXJyZW50IHN1bSBhbmQgc3VtLW9mLXNxdWFyZXMKCiAgICAgICAgc3VtICs9IHZhbDsKICAgICAgICBzdW1fc3F1YXJlcyArPSB2YWwgKiB2YWw7IC8vIHRoZSB2YXJpYW5jZSBhdCB0aGlzIHBvaW50IGluIHRoZSBzZXF1ZW5jZSBpcyB0aGUgZGlmZmVyZW5jZQogICAgICAgIC8vIGJldHdlZW4gdGhlIHN1bSBvZiBzcXVhcmVzIGFuZCB0aGUgdG90YWwgeCAyLCBvdmVyIHRoZSBudW1iZXIKICAgICAgICAvLyBvZiBzYW1wbGVzLgoKICAgICAgICB2YXJpYW5jZSA9IHN1bV9zcXVhcmVzIC0gc3VtICogc3VtIC8gdzsKICAgICAgICBpNCA9IGxvd2VyX2NsYXNzX2xpbWl0IC0gMTsKCiAgICAgICAgaWYgKGk0ICE9PSAwKSB7CiAgICAgICAgICBmb3IgKGogPSAyOyBqIDwgbl9jbGFzc2VzICsgMTsgaisrKSB7CiAgICAgICAgICAgIC8vIGlmIGFkZGluZyB0aGlzIGVsZW1lbnQgdG8gYW4gZXhpc3RpbmcgY2xhc3MKICAgICAgICAgICAgLy8gd2lsbCBpbmNyZWFzZSBpdHMgdmFyaWFuY2UgYmV5b25kIHRoZSBsaW1pdCwgYnJlYWsKICAgICAgICAgICAgLy8gdGhlIGNsYXNzIGF0IHRoaXMgcG9pbnQsIHNldHRpbmcgdGhlIGxvd2VyX2NsYXNzX2xpbWl0CiAgICAgICAgICAgIC8vIGF0IHRoaXMgcG9pbnQuCiAgICAgICAgICAgIGlmICh2YXJpYW5jZV9jb21iaW5hdGlvbnNbbF1bal0gPj0gdmFyaWFuY2UgKyB2YXJpYW5jZV9jb21iaW5hdGlvbnNbaTRdW2ogLSAxXSkgewogICAgICAgICAgICAgIGxvd2VyX2NsYXNzX2xpbWl0c1tsXVtqXSA9IGxvd2VyX2NsYXNzX2xpbWl0OwogICAgICAgICAgICAgIHZhcmlhbmNlX2NvbWJpbmF0aW9uc1tsXVtqXSA9IHZhcmlhbmNlICsgdmFyaWFuY2VfY29tYmluYXRpb25zW2k0XVtqIC0gMV07CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIGxvd2VyX2NsYXNzX2xpbWl0c1tsXVsxXSA9IDE7CiAgICAgIHZhcmlhbmNlX2NvbWJpbmF0aW9uc1tsXVsxXSA9IHZhcmlhbmNlOwogICAgfSAvLyByZXR1cm4gdGhlIHR3byBtYXRyaWNlcy4gZm9yIGp1c3QgcHJvdmlkaW5nIGJyZWFrcywgb25seQogICAgLy8gYGxvd2VyX2NsYXNzX2xpbWl0c2AgaXMgbmVlZGVkLCBidXQgdmFyaWFuY2VzIGNhbiBiZSB1c2VmdWwgdG8KICAgIC8vIGV2YWx1YWdlIGdvb2RuZXNzIG9mIGZpdC4KCgogICAgcmV0dXJuIHsKICAgICAgbG93ZXJfY2xhc3NfbGltaXRzOiBsb3dlcl9jbGFzc19saW1pdHMsCiAgICAgIHZhcmlhbmNlX2NvbWJpbmF0aW9uczogdmFyaWFuY2VfY29tYmluYXRpb25zCiAgICB9OwogIH0gLy8gdGhlIHNlY29uZCBwYXJ0IG9mIHRoZSBqZW5rcyByZWNpcGU6IHRha2UgdGhlIGNhbGN1bGF0ZWQgbWF0cmljZXMKICAvLyBhbmQgZGVyaXZlIGFuIGFycmF5IG9mIG4gYnJlYWtzLgoKCiAgZnVuY3Rpb24gYnJlYWtzKGRhdGEsIGxvd2VyX2NsYXNzX2xpbWl0cywgbl9jbGFzc2VzKSB7CiAgICB2YXIgayA9IGRhdGEubGVuZ3RoIC0gMSwKICAgICAgICBrY2xhc3MgPSBbXSwKICAgICAgICBjb3VudE51bSA9IG5fY2xhc3NlczsgLy8gdGhlIGNhbGN1bGF0aW9uIG9mIGNsYXNzZXMgd2lsbCBuZXZlciBpbmNsdWRlIHRoZSB1cHBlciBhbmQKICAgIC8vIGxvd2VyIGJvdW5kcywgc28gd2UgbmVlZCB0byBleHBsaWNpdGx5IHNldCB0aGVtCgogICAga2NsYXNzW25fY2xhc3Nlc10gPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV07CiAgICBrY2xhc3NbMF0gPSBkYXRhWzBdOyAvLyB0aGUgbG93ZXJfY2xhc3NfbGltaXRzIG1hdHJpeCBpcyB1c2VkIGFzIGluZGV4ZXMgaW50byBpdHNlbGYKICAgIC8vIGhlcmU6IHRoZSBga2AgdmFyaWFibGUgaXMgcmV1c2VkIGluIGVhY2ggaXRlcmF0aW9uLgoKICAgIHdoaWxlIChjb3VudE51bSA+IDEpIHsKICAgICAga2NsYXNzW2NvdW50TnVtIC0gMV0gPSBkYXRhW2xvd2VyX2NsYXNzX2xpbWl0c1trXVtjb3VudE51bV0gLSAyXTsKICAgICAgayA9IGxvd2VyX2NsYXNzX2xpbWl0c1trXVtjb3VudE51bV0gLSAxOwogICAgICBjb3VudE51bS0tOwogICAgfQoKICAgIHJldHVybiBrY2xhc3M7CiAgfQoKICBpZiAobl9jbGFzc2VzID4gZGF0YS5sZW5ndGgpIHJldHVybiBudWxsOyAvLyBzb3J0IGRhdGEgaW4gbnVtZXJpY2FsIG9yZGVyLCBzaW5jZSB0aGlzIGlzIGV4cGVjdGVkCiAgLy8gYnkgdGhlIG1hdHJpY2VzIGZ1bmN0aW9uCgogIGRhdGEgPSBBcnJheS5mcm9tKGRhdGEpLnNsaWNlKCkuc29ydChmdW5jdGlvbiAoYSwgYikgewogICAgcmV0dXJuIGEgLSBiOwogIH0pOyAvLyBkYXRhID0gZGF0YS5zbGljZSgpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9KTsKICAvLyBjb25zb2xlLmxvZyhkYXRhKQogIC8vIGdldCBvdXIgYmFzaWMgbWF0cmljZXMKCiAgdmFyIG1hdHJpY2VzID0gZ2V0TWF0cmljZXMoZGF0YSwgbl9jbGFzc2VzKSwKICAgICAgLy8gd2Ugb25seSBuZWVkIGxvd2VyIGNsYXNzIGxpbWl0cyBoZXJlCiAgbG93ZXJfY2xhc3NfbGltaXRzID0gbWF0cmljZXMubG93ZXJfY2xhc3NfbGltaXRzOyAvLyBleHRyYWN0IG5fY2xhc3NlcyBvdXQgb2YgdGhlIGNvbXB1dGVkIG1hdHJpY2VzCgogIHJldHVybiBicmVha3MoZGF0YSwgbG93ZXJfY2xhc3NfbGltaXRzLCBuX2NsYXNzZXMpOwp9OwoKZXhwb3J0IGRlZmF1bHQgamVua3M7"},{"version":3,"sources":["/Users/molly_s4/Desktop/code/Thesis_folders/Thesis-2022/vue-app-mc/src/jenks.js"],"names":["jenks","data","n_classes","getMatrices","lower_class_limits","variance_combinations","i","j","variance","length","tmp1","tmp2","push","Infinity","l","sum","sum_squares","w","i4","m","lower_class_limit","val","breaks","k","kclass","countNum","Array","from","slice","sort","a","b","matrices"],"mappings":"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","sourcesContent":["// # [Jenks natural breaks optimization](http://en.wikipedia.org/wiki/Jenks_natural_breaks_optimization)\n//\n// Implementations: [1](http://danieljlewis.org/files/2010/06/Jenks.pdf) (python),\n// [2](https://github.com/vvoovv/djeo-jenks/blob/master/main.js) (buggy),\n// [3](https://github.com/simogeo/geostats/blob/master/lib/geostats.js#L407) (works)\nvar jenks =\n    function jenks(data, n_classes) {\n\n        // Compute the matrices required for Jenks breaks. These matrices\n        // can be used for any classing of data with `classes <= n_classes`\n        function getMatrices(data, n_classes) {\n\n            // in the original implementation, these matrices are referred to\n            // as `LC` and `OP`\n            //\n            // * lower_class_limits (LC): optimal lower class limits\n            // * variance_combinations (OP): optimal variance combinations for all classes\n            var lower_class_limits = [],\n                variance_combinations = [],\n                // loop counters\n                i, j,\n                // the variance, as computed at each step in the calculation\n                variance = 0;\n\n            // Initialize and fill each matrix with zeroes\n            for (i = 0; i < data.length + 1; i++) {\n                var tmp1 = [], tmp2 = [];\n                for (j = 0; j < n_classes + 1; j++) {\n                    tmp1.push(0);\n                    tmp2.push(0);\n                }\n                lower_class_limits.push(tmp1);\n                variance_combinations.push(tmp2);\n            }\n\n            for (i = 1; i < n_classes + 1; i++) {\n                lower_class_limits[1][i] = 1;\n                variance_combinations[1][i] = 0;\n                // in the original implementation, 9999999 is used but\n                // since Javascript has `Infinity`, we use that.\n                for (j = 2; j < data.length + 1; j++) {\n                    variance_combinations[j][i] = Infinity;\n                }\n            }\n\n            for (var l = 2; l < data.length + 1; l++) {\n\n                // `SZ` originally. this is the sum of the values seen thus\n                // far when calculating variance.\n                var sum = 0,\n                    // `ZSQ` originally. the sum of squares of values seen\n                    // thus far\n                    sum_squares = 0,\n                    // `WT` originally. This is the number of\n                    w = 0,\n                    // `IV` originally\n                    i4 = 0;\n\n                // in several instances, you could say `Math.pow(x, 2)`\n                // instead of `x * x`, but this is slower in some browsers\n                // introduces an unnecessary concept.\n                for (var m = 1; m < l + 1; m++) {\n\n                    // `III` originally\n                    var lower_class_limit = l - m + 1,\n                        val = data[lower_class_limit - 1];\n\n                    // here we're estimating variance for each potential classing\n                    // of the data, for each potential number of classes. `w`\n                    // is the number of data points considered so far.\n                    w++;\n\n                    // increase the current sum and sum-of-squares\n                    sum += val;\n                    sum_squares += val * val;\n\n                    // the variance at this point in the sequence is the difference\n                    // between the sum of squares and the total x 2, over the number\n                    // of samples.\n                    variance = sum_squares - (sum * sum) / w;\n\n                    i4 = lower_class_limit - 1;\n\n                    if (i4 !== 0) {\n                        for (j = 2; j < n_classes + 1; j++) {\n                            // if adding this element to an existing class\n                            // will increase its variance beyond the limit, break\n                            // the class at this point, setting the lower_class_limit\n                            // at this point.\n                            if (variance_combinations[l][j] >=\n                                (variance + variance_combinations[i4][j - 1])) {\n                                lower_class_limits[l][j] = lower_class_limit;\n                                variance_combinations[l][j] = variance +\n                                    variance_combinations[i4][j - 1];\n                            }\n                        }\n                    }\n                }\n\n                lower_class_limits[l][1] = 1;\n                variance_combinations[l][1] = variance;\n            }\n\n            // return the two matrices. for just providing breaks, only\n            // `lower_class_limits` is needed, but variances can be useful to\n            // evaluage goodness of fit.\n            return {\n                lower_class_limits: lower_class_limits,\n                variance_combinations: variance_combinations\n            };\n        }\n\n\n\n        // the second part of the jenks recipe: take the calculated matrices\n        // and derive an array of n breaks.\n        function breaks(data, lower_class_limits, n_classes) {\n\n            var k = data.length - 1,\n                kclass = [],\n                countNum = n_classes;\n\n            // the calculation of classes will never include the upper and\n            // lower bounds, so we need to explicitly set them\n            kclass[n_classes] = data[data.length - 1];\n            kclass[0] = data[0];\n\n            // the lower_class_limits matrix is used as indexes into itself\n            // here: the `k` variable is reused in each iteration.\n            while (countNum > 1) {\n                kclass[countNum - 1] = data[lower_class_limits[k][countNum] - 2];\n                k = lower_class_limits[k][countNum] - 1;\n                countNum--;\n            }\n\n            return kclass;\n        }\n\n        if (n_classes > data.length) return null;\n\n        // sort data in numerical order, since this is expected\n        // by the matrices function\n\n        data = Array.from(data).slice().sort(function (a, b) { return a - b; });\n        // data = data.slice().sort(function (a, b) { return a - b; });\n\n        // console.log(data)\n\n        // get our basic matrices\n        var matrices = getMatrices(data, n_classes),\n            // we only need lower class limits here\n            lower_class_limits = matrices.lower_class_limits;\n\n        // extract n_classes out of the computed matrices\n        return breaks(data, lower_class_limits, n_classes);\n\n    }\n\nexport default jenks;"]}]}